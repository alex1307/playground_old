{
    "sourceFile": "apps/handlers/src/elavro_srv.erl",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1639128016964,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1639128016964,
            "name": "Commit-0",
            "content": "\n%%%-------------------------------------------------------------------\n%%% @author Alexander Todorov(alexander.todorov@ayagasha.com)\n%%% @copyright (C) 2020, Ayagasha Enterprises Ltd.\n%%% Company Ayagasha Enterprises Ltd.\n%%% Created On: 10-Dec-2020\n%%% @doc\n%%%\n%%% @end\n%%%-------------------------------------------------------------------\n-module(elavro_srv).\n-author(\"Alexander Todorov(alexander.todorov@ayagasha.com)\").\n\n-behaviour(gen_server).\n\n%% API\n\n%% gen_server callbacks\n-export([init/1,\n  handle_call/3,\n  handle_cast/2,\n  handle_info/2,\n  terminate/2,\n  code_change/3]).\n\n-export([start_link/1, start_link/2]).\n-export([get_records/0, get_records/1]).\n-export([get_schema/2, get_schema/1]).\n-export([get_dir/0, get_dir/1]).\n-export([get_status/0, get_status/1]).\n\n-export([encode/3, encode/2]).\n-export([decode/3, decode/2]).\n-export([avro_to_json/4, avro_to_json/2]).\n\n-define(SERVER, ?MODULE).\n-define(ENCODE(R, P), {encode, R, P}).\n-define(DECODE(R, P), {decode, R, P}).\n\n-include(\"model.hrl\").\n-include_lib(\"utils/include/service_space.hrl\").\n%%%===================================================================\n%%% API\n%%%===================================================================\n\n%% @doc Spawns the server and registers the local name (unique)\n-spec(start_link(Dir :: list()) ->\n  {ok, Pid :: pid()} | ignore | {error, Reason :: term()}).\nstart_link(Dir) ->\n  start_link(?SERVER, Dir).\n\n-spec(start_link(ServerName :: atom(), Dir :: iolist()) ->\n  {ok, Pid :: pid()} | ignore | {error, Reason :: term()}).\nstart_link(ServerName, Dir) ->\n  gen_server:start_link({local, ServerName}, ?MODULE, [Dir], []).\n\n\n%%%===================================================================\n%%% gen_server callbacks\n%%%===================================================================\n\n%% @private\n%% @doc Initializes the server\n-spec(init(Args :: term()) ->\n  {ok, State :: #avro_handler_state{}} | {ok, State :: #avro_handler_state{}, timeout() | hibernate} |\n  {stop, Reason :: term()} | ignore).\ninit([Dir]) ->\n  State = handlers_utils:load_resources(Dir),\n  {ok, State}.\n\n\n%% @private\n%% @doc Handling call messages\n-spec(handle_call(Request :: {atom(), list()} | {atom(), binary()}, From :: {pid(), Tag :: term()},\n    State :: #avro_handler_state{}) ->\n  {reply, Reply :: term(), NewState :: #avro_handler_state{}} |\n  {reply, Reply :: term(), NewState :: #avro_handler_state{}, timeout() | hibernate} |\n  {noreply, NewState :: #avro_handler_state{}} |\n  {noreply, NewState :: #avro_handler_state{}, timeout() | hibernate} |\n  {stop, Reason :: term(), Reply :: term(), NewState :: #avro_handler_state{}} |\n  {stop, Reason :: term(), NewState :: #avro_handler_state{}}).\n\nhandle_call(status, _From, State = #avro_handler_state{status = Status}) ->\n  {reply, Status, State};\n\nhandle_call(dir, _From, State = #avro_handler_state{status = ok, schema_dir = Dir}) ->\n  {reply, Dir, State};\n\nhandle_call(records, _From, State = #avro_handler_state{status = ok, schemas = Schemas}) ->\n  maps:keys(Schemas),\n  {reply, maps:keys(Schemas), State};\n\nhandle_call({schema, SchemaName}, _From, State = #avro_handler_state{status = ok, schemas = Schemas}) ->\n  {reply, maps:get(SchemaName, Schemas), State};\n\nhandle_call(?ENCODE(RecordName, Payload), _From, State = #avro_handler_state{status = ok, encoders = Encoders}) ->\n  IS_KEY = maps:is_key(RecordName, Encoders),\n  if\n    IS_KEY ->\n      Encoder = maps:get(RecordName, Encoders),\n      try Encoder(Payload) of\n        IOList when is_list(IOList) ->\n          {reply, iolist_to_binary(IOList), State}\n        catch\n          error:Reason ->\n            lager:error(\"Avro parsing error: ~p\", [Reason]),\n            {reply, ?INVALID_AVRO, State}\n      end;\n    true ->\n      {reply, ?RECORD_NOT_FOUND, State}\n  end;\n\nhandle_call(?DECODE(RecordName, Payload), _From, State = #avro_handler_state{status = ok, decoders = Decoders}) ->\n  IS_KEY = maps:is_key(RecordName, Decoders),\n  if\n    IS_KEY ->\n      Decoder = maps:get(RecordName, Decoders),\n      {reply, Decoder(Payload), State};\n    true ->\n      {reply, record_not_found, State}\n  end;\n\nhandle_call(_Request, _From, State = #avro_handler_state{status = Nok}) when Nok =/= ok ->\n  {reply, Nok, State};\n\nhandle_call(_Request, _From, State = #avro_handler_state{}) ->\n  {reply, ok, State}.\n\n%% @private\n%% @doc Handling cast messages\n-spec(handle_cast(Request :: term(), State :: #avro_handler_state{}) ->\n  {noreply, NewState :: #avro_handler_state{}} |\n  {noreply, NewState :: #avro_handler_state{}, timeout() | hibernate} |\n  {stop, Reason :: term(), NewState :: #avro_handler_state{}}).\nhandle_cast(_Request, State = #avro_handler_state{}) ->\n  {noreply, State}.\n\n%% @private\n%% @doc Handling all non call/cast messages\n-spec(handle_info(Info :: timeout() | term(), State :: #avro_handler_state{}) ->\n  {noreply, NewState :: #avro_handler_state{}} |\n  {noreply, NewState :: #avro_handler_state{}, timeout() | hibernate} |\n  {stop, Reason :: term(), NewState :: #avro_handler_state{}}).\nhandle_info(_Info, State = #avro_handler_state{}) ->\n  {noreply, State}.\n\n%% @private\n%% @doc This function is called by a gen_server when it is about to\n%% terminate. It should be the opposite of Module:init/1 and do any\n%% necessary cleaning up. When it returns, the gen_server terminates\n%% with Reason. The return value is ignored.\n-spec(terminate(Reason :: (normal | shutdown | {shutdown, term()} | term()),\n    State :: #avro_handler_state{}) -> term()).\nterminate(_Reason, _State = #avro_handler_state{}) ->\n  ok.\n\n%% @private\n%% @doc Convert process state when code is changed\n-spec(code_change(OldVsn :: term() | {down, term()}, State :: #avro_handler_state{},\n    Extra :: term()) ->\n  {ok, NewState :: #avro_handler_state{}} | {error, Reason :: term()}).\ncode_change(_OldVsn, State = #avro_handler_state{}, _Extra) ->\n  {ok, State}.\n\n%%%===================================================================\n%%% Internal functions\n%%%===================================================================\n\n-spec(decode(ServerName :: atom(), Record :: atom(), Binary :: binary()) -> [A] | invalid_function_call | record_not_found\n  when A :: tuple()).\ndecode(ServerName, Record, Binary)\n  when is_atom(ServerName) andalso is_atom(Record) andalso is_binary(Binary) ->\n  gen_server:call(ServerName, ?DECODE(Record, Binary));\n\ndecode(_ServerName, _Rec, _Bin) ->\n  ?INVALID_FUNCTION_CALL.\n\n-spec(decode(Record :: atom(), Term :: binary()) -> [A] | invalid_function_call | record_not_found\n  when A :: tuple()).\ndecode(Record, Binary) ->\n  decode(?SERVER, Record, Binary).\n\n\n-spec(encode(ServerName :: atom(), Record :: atom(), TupleList :: [A]) -> binary() | invalid_function_call | record_not_found\n  when A :: tuple()).\nencode(ServerName, Record, TupleList) ->\n  encode(ServerName, Record, TupleList, ?IS_PROCESS_ALIVE(ServerName)).\n\nencode(ServerName, Record, TupleList, true)\n  when is_atom(ServerName) andalso is_atom(Record) andalso is_list(TupleList) ->\n  gen_server:call(ServerName, ?ENCODE(Record, TupleList));\n\nencode(_ServerName, _Record, _TupleList, true) ->\n  ?INVALID_FUNCTION_CALL;\n\nencode(ServerName, _Record, _TupleList, false)\n  when is_atom(ServerName) ->\n  lager:error(\"Server ~p is not running\", [ServerName]),\n  ?SERVER_IS_NOT_RUNNING.\n\n\n-spec(encode(Record :: atom(), Term :: binary()) -> [A] | invalid_function_call | record_not_found\n  when A :: tuple()).\nencode(Record, TupleList) ->\n  encode(?SERVER, Record, TupleList).\n\n-spec(avro_to_json(AvroSrv :: atom(), JsonSrv :: atom(), RecordName :: atom(), Binary :: binary()) -> binary() | invalid_parameters).\navro_to_json(AvroSrv, JsonSrv, RecordName, Binary)\n  when is_atom(AvroSrv) andalso is_atom(JsonSrv) andalso is_atom(RecordName) andalso is_binary(Binary) ->\n  TupleList = encode(AvroSrv, RecordName, Binary),\n  jiffy_srv:tuple_list_to_binary(JsonSrv, TupleList);\n\navro_to_json(_AvroSrv, _JsonSrv, _RecordName, _Binary) ->\n  ?INVALID_FUNCTION_CALL.\n\n-spec(avro_to_json(RecordName :: atom(), Binary :: binary()) -> binary() | invalid_parameters).\navro_to_json(RecordName, Binary)\n  when is_atom(RecordName) andalso is_binary(Binary) ->\n  TupleList = decode(RecordName, Binary),\n  jiffy_srv:tuple_list_to_binary(TupleList).\n\n\nget_status(ServerName) ->\n  gen_server:call(ServerName, status).\n\nget_status() ->\n  get_status(?SERVER).\n\nget_dir(ServerName) ->\n  gen_server:call(ServerName, dir).\n\nget_dir() ->\n  get_dir(?SERVER).\n\nget_records(ServerName) ->\n  gen_server:call(ServerName, records).\n\nget_records() ->\n  get_records(?SERVER).\n\nget_schema(ServerName, RecordName) ->\n  gen_server:call(ServerName, {schema, RecordName}).\n\nget_schema(RecordName) ->\n  get_schema(?SERVER, RecordName).\n"
        }
    ]
}