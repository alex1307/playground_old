{
    "sourceFile": "apps/load_balancer/src/load_balancer_srv.erl",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 4,
            "patches": [
                {
                    "date": 1639126453172,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1639126458545,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -172,9 +172,9 @@\n \n execute_call(_Servers, _Request, _Source) ->\n   error.\n \n-execute_cast([Server | T], Option, Source) when T == [] ->\n+execute_cast([Server | T], Option, _Source) when T == [] ->\n   Response = gen_server:cast(Server, Option),\n   {Response, Source};\n \n execute_cast([Server | T], Option, Source) when T =/= [] ->\n"
                },
                {
                    "date": 1639126464563,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -176,9 +176,9 @@\n execute_cast([Server | T], Option, _Source) when T == [] ->\n   Response = gen_server:cast(Server, Option),\n   {Response, Source};\n \n-execute_cast([Server | T], Option, Source) when T =/= [] ->\n+execute_cast([Server | T], Option, _Source) when T =/= [] ->\n   Response = gen_server:cast(Server, Option),\n   {Response, T};\n \n \n"
                },
                {
                    "date": 1639126475338,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -181,9 +181,9 @@\n   Response = gen_server:cast(Server, Option),\n   {Response, T};\n \n \n-execute_cast([Server | T], Option, _Source) ->\n+execute_cast([_Server | _T], _Option, _Source) ->\n   error.\n \n configure_delay_in_ms(ServerName, Millis) ->\n   gen_server:call(ServerName, {delay, Millis}).\n"
                },
                {
                    "date": 1639126483128,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -172,9 +172,9 @@\n \n execute_call(_Servers, _Request, _Source) ->\n   error.\n \n-execute_cast([Server | T], Option, _Source) when T == [] ->\n+execute_cast([Server | T], Option, Source) when T == [] ->\n   Response = gen_server:cast(Server, Option),\n   {Response, Source};\n \n execute_cast([Server | T], Option, _Source) when T =/= [] ->\n"
                }
            ],
            "date": 1639126453172,
            "name": "Commit-0",
            "content": "%%%-------------------------------------------------------------------\n%%% @author alex\n%%% @copyright (C) 2021, <COMPANY>\n%%% @doc\n%%%\n%%% @end\n%%% Created : 21. Jun 2021 8:51\n%%%-------------------------------------------------------------------\n-module(load_balancer_srv).\n-author(\"alex\").\n\n-behaviour(gen_server).\n\n%% API\n-export([start_link/3]).\n-export([send_message/2, send_message/1,\n  configure_limiter/2,\n  configure_delay_and_limiter/3,\n  configure_delay_in_ms/2]).\n%% gen_server callbacks\n-export([init/1, handle_call/3, handle_cast/2, handle_info/2, terminate/2,\n  code_change/3]).\n\n-define(SERVER, ?MODULE).\n\n-record(lb_state, {\n  servers :: list(),\n  executors :: list(),\n  delay :: integer(),\n  rate :: integer(),\n  limiter :: integer(),\n  type :: atom()\n}).\n\n%%%===================================================================\n%%% API\n%%%===================================================================\n\n%% @doc Spawns the server and registers the local name (unique)\n-spec(start_link(ServerName :: atom(), Servers :: list(), Type :: atom()) ->\n  {ok, Pid :: pid()} | ignore | {error, Reason :: term()}).\nstart_link(ServerName, Servers, Type)\n  when is_atom(ServerName) andalso is_list(Servers) ->\n  gen_server:start_link({local, ServerName}, ?MODULE, [Servers, Type], []).\n\n\n%%%===================================================================\n%%% gen_server callbacks\n%%%===================================================================\n\n%% @private\n%% @doc Initializes the server\n-spec(init(Args :: term()) ->\n  {ok, State :: #lb_state{}} | {ok, State :: #lb_state{}, timeout() | hibernate} |\n  {stop, Reason :: term()} | ignore).\ninit([Servers, call]) when is_list(Servers) ->\n  {ok, #lb_state{servers = Servers,\n    type = call,\n    delay = 2,\n    rate = 1,\n    limiter = 20,\n    executors = Servers}};\n\ninit([Servers, cast]) when is_list(Servers) ->\n  {ok, #lb_state{servers = Servers, type = cast, executors = Servers}};\n\ninit([_Any]) ->\n  {stop, invalid_parameters}.\n\n\n%% @private\n%% @doc Handling call messages\n-spec(handle_call(Request :: term(), From :: {pid(), Tag :: term()},\n    State :: #lb_state{}) ->\n  {reply, Reply :: term(), NewState :: #lb_state{}} |\n  {reply, Reply :: term(), NewState :: #lb_state{}, timeout() | hibernate} |\n  {noreply, NewState :: #lb_state{}} |\n  {noreply, NewState :: #lb_state{}, timeout() | hibernate} |\n  {stop, Reason :: term(), Reply :: term(), NewState :: #lb_state{}} |\n  {stop, Reason :: term(), NewState :: #lb_state{}}).\nhandle_call({configure, Delay, Limiter}, _From, State) ->\n  {reply, State, State#lb_state{limiter = Limiter, delay = Delay}};\n\nhandle_call({delay, Delay}, _From, State) ->\n  {reply, State, State#lb_state{delay = Delay}};\n\nhandle_call({limiter, Limiter}, _From, State) ->\n  {reply, State, State#lb_state{limiter = Limiter}};\n\nhandle_call(Request, _From, State = #lb_state{executors = Executors, servers = Servers, rate = Rate, limiter = Limiter}) when Rate =< Limiter ->\n  case execute_call(Executors, Request, Servers) of\n    {Response, Reduced} when is_list(Reduced) ->\n      {reply, Response, State#lb_state{executors = Reduced, rate = Rate + 1}};\n    _Any ->\n      {reply, error, State}\n  end;\nhandle_call(Request, _From, State = #lb_state{executors = Executors, servers = Servers, rate = Rate, limiter = Limiter, delay = Delay}) when Rate > Limiter ->\n  case execute_call(Executors, Request, Servers, Delay) of\n    {Response, Reduced} when is_list(Reduced) ->\n      {reply, Response, State#lb_state{executors = Reduced, rate = 1}};\n    _Any ->\n      {reply, error, State}\n  end.\n\n\n%% @private\n%% @doc Handling cast messages\n-spec(handle_cast(Request :: term(), State :: #lb_state{}) ->\n  {noreply, NewState :: #lb_state{}} |\n  {noreply, NewState :: #lb_state{}, timeout() | hibernate} |\n  {stop, Reason :: term(), NewState :: #lb_state{}}).\nhandle_cast(Request, State = #lb_state{executors = Executors, servers = Servers, rate = Rate, limiter = Limiter, delay = Delay}) when Rate > Limiter ->\n  case execute_call(Executors, Request, Servers) of\n    {Response, Reduced} when is_list(Reduced) ->\n      {noreply, State#lb_state{executors = Reduced, rate = Rate + 1}};\n    _Any ->\n      {noreply, State}\n  end;\nhandle_cast(Request, State = #lb_state{executors = Executors, servers = Servers, rate = Rate, limiter = Limiter, delay = Delay}) ->\n  case execute_call(Executors, Request, Servers, Delay) of\n    {Response, Reduced} when is_list(Reduced) ->\n      {noreply, State#lb_state{executors = Reduced, rate = 1}};\n    _Any ->\n      {noreply, State}\n  end.\n\n\nhandle_info(_Info, State) ->\n  {noreply, State}.\n\n%% @private\n%% @doc This function is called by a gen_server when it is about to\n%% terminate. It should be the opposite of Module:init/1 and do any\n%% necessary cleaning up. When it returns, the gen_server terminates\n%% with Reason. The return value is ignored.\n-spec(terminate(Reason :: (normal | shutdown | {shutdown, term()} | term()),\n    State :: #lb_state{}) -> term()).\nterminate(_Reason, _State = #lb_state{}) ->\n  ok.\n\n%% @private\n%% @doc Convert process state when code is changed\n-spec(code_change(OldVsn :: term() | {down, term()}, State :: #lb_state{},\n    Extra :: term()) ->\n  {ok, NewState :: #lb_state{}} | {error, Reason :: term()}).\ncode_change(_OldVsn, State = #lb_state{}, _Extra) ->\n  {ok, State}.\n\n%%%===================================================================\n%%% Internal functions\n%%%===================================================================\n\nsend_message(ServerName, Message) ->\n  gen_server:cast(ServerName, {send, Message}).\n\nsend_message(Message) ->\n  send_message(?SERVER, Message).\n\nexecute_call([Server | T], Request, Source, DelayMs) ->\n  timer:sleep(DelayMs),\n  execute_call([Server | T], Request, Source).\n\n\nexecute_call([Server | T], Request, Source) when T == [] ->\n  Response = gen_server:call(Server, Request),\n  {Response, Source};\n\nexecute_call([Server | T], Request, _Source) when T =/= [] ->\n  Response = gen_server:call(Server, Request),\n  {Response, T};\n\n\nexecute_call(_Servers, _Request, _Source) ->\n  error.\n\nexecute_cast([Server | T], Option, Source) when T == [] ->\n  Response = gen_server:cast(Server, Option),\n  {Response, Source};\n\nexecute_cast([Server | T], Option, Source) when T =/= [] ->\n  Response = gen_server:cast(Server, Option),\n  {Response, T};\n\n\nexecute_cast([Server | T], Option, _Source) ->\n  error.\n\nconfigure_delay_in_ms(ServerName, Millis) ->\n  gen_server:call(ServerName, {delay, Millis}).\n\nconfigure_limiter(ServerName, Limiter) ->\n  gen_server:call(ServerName, {limiter, Limiter}).\n\nconfigure_delay_and_limiter(ServerName, Millis, Limiter) ->\n  gen_server:call(ServerName, {configure, Millis, Limiter}).\n\n\n"
        }
    ]
}