{
    "sourceFile": "apps/udp_srv/src/udp_srv.erl",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1639128559451,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1639128559451,
            "name": "Commit-0",
            "content": "%%%-------------------------------------------------------------------\n%%% @author Alexander Todorov(alexander.todorov@ayagasha.com)\n%%% @copyright (C) 2020, Ayagasha Enterprises Ltd.\n%%% Company Ayagasha Enterprises Ltd.\n%%% Created On: 11-Dec-2020\n%%% @doc\n%%%\n%%% @end\n%%%-------------------------------------------------------------------\n-module(udp_srv).\n-author(\"Alexander Todorov(alexander.todorov@ayagasha.com)\").\n\n-behaviour(application).\n-include(\"message_protocol.hrl\").\n-include_lib(\"utils/include/servers.hrl\").\n%% Application callbacks\n-export([\n  start/2,\n  stop/1]).\n\n%%%===================================================================\n%%% Application callbacks\n%%%===================================================================\n\n%%--------------------------------------------------------------------\n%% @private\n%% @doc\n%% This function is called whenever an application is started using\n%% application:start/[1,2], and should start the processes of the\n%% application. If the application is structured according to the OTP\n%% design principles as a supervision tree, this means starting the\n%% top supervisor of the tree.\n%%\n%% @end\n%%--------------------------------------------------------------------\n-spec(start(StartType :: normal | {takeover, node()} | {failover, node()},\n    StartArgs :: term()) ->\n  {ok, pid()} |\n  {ok, pid(), State :: term()} |\n  {error, Reason :: term()}).\nstart(_StartType, _StartArgs) ->\n  lager:info(\"Starting main app\"),\n  Port = application:get_env(udp_srv, port, 5663),\n  IPs = application:get_env(udp_srv, hosts, [{localhost, {0, 0, 0, 0}}]),\n  lists:foreach(\n    fun({ServerName, IP}) ->\n      Bin = atom_to_binary(ServerName),\n      SupName = <<Bin/binary, \"_sup\">>,\n      app_supervisor:start_child(binary_to_atom(SupName), udp_server, start_link, [ServerName, Port, IP])\n    end,\n    IPs),\n  app_supervisor:start_child(messages_sup, message_processor, start_link, [?MESSAGE_SRV]),\n  app_supervisor:start_child(ack_sup, message_processor, start_link, [?ACK_SRV]),\n  app_supervisor:start_child(sync_sup, message_processor, start_link, [?SYNC_SRV]),\n  app_supervisor:start_child(outgoing_msg_counter_sup , message_counter, start_link, [?OUTGOING_MESSAGE_COUNTER_SRV]),\n  app_supervisor:start_child(incoming_msg_counter_sup, message_counter, start_link, [?INCOMING_MESSAGE_COUNTER_SRV]),\n  message_counter:set_interval(?INCOMING_MESSAGE_COUNTER_SRV, 1000),\n  message_counter:set_interval(?OUTGOING_MESSAGE_COUNTER_SRV, 1000),\n  print_cheat_sheet(),\n  {ok, self()}.\n\nprint_cheat_sheet() ->\n  lager:info(\"====================================== Useful commands ======================================\"),\n  lager:info(\"OUT_SRV = ~p\", [?OUTGOING_MESSAGE_COUNTER_SRV]),\n  lager:info(\"IN_SRV = ~p\", [?INCOMING_MESSAGE_COUNTER_SRV]),\n  lager:info(\"F = fun(Server, Message) -> gen_server:call(Server, {message, Message}) end.\"),\n  lager:info(\"M = scenarios:create_message_with_size(2047).\"),\n  lager:info(\"W = fun(Server, Message, Iterations) -> lists:foreach(fun(_) ->  F(Server, Message) end, lists:seq(1, Iterations)) end.\"),\n  lager:info(\"S = fun(Server, Message, Iterations) -> spawn(fun() -> W(Server, Message, Iterations) end) end.\"),\n  lager:info(\"S(worker1, M, 100000), S(worker2, M, 100000), S(worker3, M, 100000)\"),\n  lager:info(\"=============================================================================================\").\n\n%%--------------------------------------------------------------------\n%% @private\n%% @doc\n%% This function is called whenever an application has stopped. It\n%% is intended to be the opposite of Module:start/2 and should do\n%% any necessary cleaning up. The return value is ignored.\n%%\n%% @end\n%%--------------------------------------------------------------------\n-spec(stop(State :: term()) -> term()).\nstop(_State) ->\n  ok.\n\n%%%===================================================================\n%%% Internal functions\n%%%===================================================================\n"
        }
    ]
}