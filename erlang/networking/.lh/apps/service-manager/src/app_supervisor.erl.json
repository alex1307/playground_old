{
    "sourceFile": "apps/service-manager/src/app_supervisor.erl",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1639128692068,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1639128692068,
            "name": "Commit-0",
            "content": "%%%-------------------------------------------------------------------\n%%% @author alex\n%%% @copyright (C) 2020, <COMPANY>\n%%% @doc\n%%%\n%%% @end\n%%% Created : 10. Jul 2020 9:08\n%%%-------------------------------------------------------------------\n-module(app_supervisor).\n-author(\"alex\").\n\n-behaviour(supervisor).\n\n%% API\n-export([start_link/0, start_global/2]).\n\n%% Supervisor callbacks\n-export([init/1]).\n\n-export([start_child/4, start_child/5]).\n-export([terminate_child/1, processes/1]).\n\n-define(SERVER, ?MODULE).\n\n%%%===================================================================\n%%% API functions\n%%%===================================================================\n\n%% @doc Starts the supervisor\n-spec(start_link() -> {ok, Pid :: pid()} | ignore | {error, Reason :: term()}).\nstart_link() ->\n  supervisor:start_link({local, ?SERVER}, ?MODULE, []).\n\nstart_global(Name, Host) ->\n  supervisor:start_link({global, {Name, Host}}, ?MODULE, []).\n\n%%%===================================================================\n%%% Supervisor callbacks\n%%%===================================================================\n\n%% @private\n%% @doc Whenever a supervisor is started using supervisor:start_link/[2,3],\n%% this function is called by the new process to find out about\n%% restart strategy, maximum restart frequency and child\n%% specifications.\n-spec(init(Args :: term()) ->\n  {ok, {SupFlags :: {RestartStrategy :: supervisor:strategy(),\n    MaxR :: non_neg_integer(), MaxT :: non_neg_integer()},\n    [ChildSpec :: supervisor:child_spec()]}}\n  | ignore | {error, Reason :: term()}).\ninit([]) ->\n  MaxRestarts = 1000,\n  MaxSecondsBetweenRestarts = 3600,\n  SupFlags = #{strategy => one_for_one,\n    intensity => MaxRestarts,\n    period => MaxSecondsBetweenRestarts},\n  lager:info(\"[~p]:[~p] ~p <<<SYSTEM>>> Supervisor [~p] is started\",\n    [?MODULE, ?LINE, self(), ?MODULE]),\n  {ok, {SupFlags, []}}.\n\n%%%===================================================================\n%%% Internal functions\n%%%===================================================================\nchild(Name, Mod, Fun, Args, Opts)\n  when is_atom(Name) andalso is_atom(Mod) andalso is_atom(Fun) andalso is_list(Args) andalso is_list(Opts)->\n  #{id => Name,\n    start => {Mod, Fun, Args, [Opts]},\n    restart => permanent,\n    shutdown => 2000,\n    type => worker,\n    modules => [Mod]};\n\n\nchild(_Name, _Mod, _Fun, _Args, _Opts) ->\n  error.\n\n\nchild(Name, Mod, Fun, Args)\n  when is_atom(Name) andalso is_atom(Mod) andalso is_atom(Fun) andalso is_list(Args) ->\n  #{id => Name,\n    start => {Mod, Fun, Args},\n    restart => permanent,\n    shutdown => 2000,\n    type => worker,\n    modules => [Mod]};\n\n\nchild(_Name, _Mod, _Fun, _Args) ->\n  error.\n\n\nstart_child(Name, Mod, Fun, Args) ->\n  case child(Name, Mod, Fun, Args) of\n    error ->\n      lager:error(\"[~p]:[~p] ~p <<<SYSTEM>>> Can't start process \\n\\t [{name: ~p}, {module, ~p}, {function: ~p}, {args, ~p}].\",\n        [?MODULE, ?LINE, self(), Name, Mod, Fun, Args]),\n      error;\n    Child ->\n      lager:info(\"Starting child: ~p\", [Child]),\n      Res = supervisor:start_child(?MODULE, Child),\n      lager:info(\"[~p]:[~p] ~p <<<SYSTEM>>> Process [~p] is started\", [?MODULE, ?LINE, self(), Name]),\n      lager:info(\"Response ~p\", [Res]),\n\n      Res\n  end.\n\nstart_child(Name, Mod, Fun, Args, Options) ->\n  case child(Name, Mod, Fun, Args, Options) of\n    error ->\n      lager:error(\"[~p]:[~p] ~p <<<SYSTEM>>> Can't start process \\n\\t [{name: ~p}, {module, ~p}, {function: ~p}, {args, ~p}].\",\n        [?MODULE, ?LINE, self(), Name, Mod, Fun, Args]),\n      error;\n    Child ->\n      lager:info(\"Starting child: ~p\", [Child]),\n      Res = supervisor:start_child(?MODULE, Child),\n      lager:info(\"[~p]:[~p] ~p <<<SYSTEM>>> Process [~p] is started\", [?MODULE, ?LINE, self(), Name]),\n      lager:info(\"Response ~p\", [Res]),\n\n      Res\n  end.\n\n\n\n\n\nterminate_child(Name) ->\n  lager:info(\"[~p]:[~p] ~p <<<SYSTEM>>> Process [~p] is being terminated.\",\n    [?MODULE, ?LINE, self(), Name]),\n  supervisor:terminate_child(?MODULE, Name),\n  supervisor:delete_child(?MODULE, Name),\n  lager:info(\"[~p]:[~p] ~p <<<SYSTEM>>> Process [~p] is terminated\", [?MODULE, ?LINE, self(), Name]).\n\n-spec(processes(Module :: module()) ->\n  {ok, Children :: list()}).\n\nprocesses(Module) ->\n  lager:info(\"Start: ~p, Server: ~p\", [Module, ?SERVER]),\n  Children = supervisor:which_children(?SERVER),\n  lager:info(\"Children: ~p\", [Children]),\n  Filtered = lists:filter(\n    fun({_Id, _Child, _Type, Modules}) ->\n      lists:any(fun(M) -> M == Module end, Modules)\n    end,\n    Children),\n  {ok, lists:map(\n    fun({_, Pid, _, _})\n      -> Pid\n    end,\n    Filtered)}.\n"
        }
    ]
}