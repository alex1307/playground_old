{
    "sourceFile": "scraper/src/collins_scraper.rs",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 6,
            "patches": [
                {
                    "date": 1641795268690,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1641796451381,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,6 +1,6 @@\n use log::error;\n-use crate::{files::file_name, HTML_EXT, domain::DictionaryEntry};\n+\n use super::{\n     description, elements, mp3_element, mp3_element_to_url, to_url, wget, download_from_url,\n };\n \n"
                },
                {
                    "date": 1641796458206,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,5 +1,6 @@\n use log::error;\n+use crate::model::DictionaryEntry;\n \n use super::{\n     description, elements, mp3_element, mp3_element_to_url, to_url, wget, download_from_url,\n };\n"
                },
                {
                    "date": 1641796468958,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -65,11 +65,9 @@\n     })\n }\n #[cfg(test)]\n mod collins_unit_tests{\n-    use crate::scraper::collins_scraper;\n-\n-\n+    \n     #[tokio::test]\n     async fn scrape_test() {\n         let html = collins_scraper::scrape(\"dust up\").await;\n         assert!(html.is_some());\n"
                },
                {
                    "date": 1641796475038,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -65,8 +65,10 @@\n     })\n }\n #[cfg(test)]\n mod collins_unit_tests{\n+    use crate::collins_scraper;\n+\n     \n     #[tokio::test]\n     async fn scrape_test() {\n         let html = collins_scraper::scrape(\"dust up\").await;\n"
                },
                {
                    "date": 1641796486945,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,4 +1,5 @@\n+use common_libs::files::file_name;\n use log::error;\n use crate::model::DictionaryEntry;\n \n use super::{\n"
                },
                {
                    "date": 1641796499075,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,7 +1,7 @@\n use common_libs::files::file_name;\n use log::error;\n-use crate::model::DictionaryEntry;\n+use crate::{model::DictionaryEntry, constants::HTML_EXT};\n \n use super::{\n     description, elements, mp3_element, mp3_element_to_url, to_url, wget, download_from_url,\n };\n"
                }
            ],
            "date": 1641795268690,
            "name": "Commit-0",
            "content": "use log::error;\nuse crate::{files::file_name, HTML_EXT, domain::DictionaryEntry};\nuse super::{\n    description, elements, mp3_element, mp3_element_to_url, to_url, wget, download_from_url,\n};\n\nconst URL: &str = r#\"https://www.collinsdictionary.com/dictionary/english/\"#;\npub const MP3_QUERY: &str =\n    r#\"a[class=\"hwd_sound sound audio_play_button icon-volume-up ptr\"]\"#;\npub const MP3_START_WITH: &str = r#\"https:\"#;\npub const DEFINITION_QUERY: &str = r#\"div[class=\"sense\"] div[class=\"def\"]\"#;\n\nfn mp3_url(html: &str) -> Option<String> {\n    let element = mp3_element(MP3_QUERY, &html);\n\n    if element.is_none() {\n        return None;\n    }\n\n    mp3_element_to_url(&element.unwrap(), MP3_START_WITH)\n}\n\nfn to_definitions(html: &str) -> Vec<String> {\n    let definitions = elements(DEFINITION_QUERY, &html, true);\n    definitions\n        .into_iter()\n        .map(|e| description(e))\n        .filter(Option::is_some)\n        .map(Option::unwrap)\n        .collect()\n}\n\npub async fn scrape(word: &str) -> Option<DictionaryEntry> {\n    if word.trim().is_empty() || word.trim().len() < 3 {\n        error!(\"word.min.lenght.is.3\");\n        return None;\n    }\n\n    let url = to_url(URL, word);\n    let html = match download_from_url(&url).await {\n        Ok(content) => content,\n        Err(_err) => {\n            error!(\"failed.to.read.from.url: {}\", url);\n            let file_name = file_name(\"download/tmp/collins\", word, HTML_EXT);\n            match wget(&url, &file_name) {\n                Ok(html) => html,\n                Err(_err) => {\n                    error!(\"resource.not.found: {}\", url);\n                    return None\n                }\n            }\n        }\n    };\n    let mp3_link = mp3_url(&html);\n    let definitions = to_definitions(&html);\n\n    Some(DictionaryEntry {\n        source: super::Dictionary::Cambridge,\n        word: word.clone().to_lowercase(),\n        url: to_url(URL, word),\n        mp3_link,\n        definitions,\n        file: None,\n    })\n}\n#[cfg(test)]\nmod collins_unit_tests{\n    use crate::scraper::collins_scraper;\n\n\n    #[tokio::test]\n    async fn scrape_test() {\n        let html = collins_scraper::scrape(\"dust up\").await;\n        assert!(html.is_some());\n        println!(\"{:?}\", html.unwrap());\n    }\n\n    #[tokio::test]\n    async fn collins_scraper_test() {\n        let res = collins_scraper::scrape(r#\"correct\"#).await;\n        assert!(res.is_some());\n        println!(\n            \"found: {}\",\n            serde_json::to_string_pretty(&res.unwrap()).unwrap()\n        );\n    }\n\n}\n"
        }
    ]
}