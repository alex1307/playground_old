{
    "sourceFile": "common_libs/src/files.rs",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 7,
            "patches": [
                {
                    "date": 1641794179690,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1641794211151,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -6,8 +6,9 @@\n use log::{error, info};\n use serde::{de::DeserializeOwned, Serialize};\n \n use crate::MAX_32_MB;\n+use crate::error::DictionaryError;\n use crate::utils::trim_tabs;\n \n const SPLITTERS: [&str; 8] = [\",\", \";\", \":\", \"?\", \"!\", \"/\", \"\\\\\", \".\"];\n const FILES_NOT_FOUND: &str = \"files.not.found\";\n"
                },
                {
                    "date": 1641794224342,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -6,9 +6,9 @@\n use log::{error, info};\n use serde::{de::DeserializeOwned, Serialize};\n \n use crate::MAX_32_MB;\n-use crate::error::DictionaryError;\n+use crate::error::{DictionaryError, DictionaryErrorKind};\n use crate::utils::trim_tabs;\n \n const SPLITTERS: [&str; 8] = [\",\", \";\", \":\", \"?\", \"!\", \"/\", \"\\\\\", \".\"];\n const FILES_NOT_FOUND: &str = \"files.not.found\";\n"
                },
                {
                    "date": 1641794372127,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -6,9 +6,9 @@\n use log::{error, info};\n use serde::{de::DeserializeOwned, Serialize};\n \n use crate::MAX_32_MB;\n-use crate::error::{DictionaryError, DictionaryErrorKind};\n+use crate::error::{DictionaryError, DictionaryErrorKind, ServiceExuctionResult};\n use crate::utils::trim_tabs;\n \n const SPLITTERS: [&str; 8] = [\",\", \";\", \":\", \"?\", \"!\", \"/\", \"\\\\\", \".\"];\n const FILES_NOT_FOUND: &str = \"files.not.found\";\n"
                },
                {
                    "date": 1641794404389,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -6,9 +6,9 @@\n use log::{error, info};\n use serde::{de::DeserializeOwned, Serialize};\n \n use crate::MAX_32_MB;\n-use crate::error::{DictionaryError, DictionaryErrorKind, ServiceExuctionResult};\n+use crate::error::{DictionaryError, DictionaryErrorKind, ServiceExuctionResult, ServiceError, ServiceErrorType};\n use crate::utils::trim_tabs;\n \n const SPLITTERS: [&str; 8] = [\",\", \";\", \":\", \"?\", \"!\", \"/\", \"\\\\\", \".\"];\n const FILES_NOT_FOUND: &str = \"files.not.found\";\n"
                },
                {
                    "date": 1642527236565,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -7,9 +7,9 @@\n use serde::{de::DeserializeOwned, Serialize};\n \n use crate::MAX_32_MB;\n use crate::error::{DictionaryError, DictionaryErrorKind, ServiceExuctionResult, ServiceError, ServiceErrorType};\n-use crate::utils::trim_tabs;\n+use crate::utils::{trim_tabs, from_binary};\n \n const SPLITTERS: [&str; 8] = [\",\", \";\", \":\", \"?\", \"!\", \"/\", \"\\\\\", \".\"];\n const FILES_NOT_FOUND: &str = \"files.not.found\";\n \n@@ -144,26 +144,11 @@\n     } else {\n         return None;\n     };\n \n-    if binary.is_empty() {\n-        error!(\"file.[{}]is.empty\", file_name.as_ref());\n-        return None;\n+    match  from_binary(binary){\n+        \n     }\n-    let string = match String::from_utf8(binary) {\n-        Ok(utf8) => utf8,\n-        Err(err) => {\n-            error!(\"file.[{}]is.not.readable. Err: {}\", file_name.as_ref(), err);\n-            return None;\n-        }\n-    };\n-    match serde_json::from_str::<T>(&string) {\n-        Ok(json) => Some(json),\n-        Err(err) => {\n-            error!(\"deserialization.failed.for: {}. Err: {}\", file_name.as_ref(), err);\n-            None\n-        }\n-    }\n }\n \n pub fn parse_file<T: AsRef<str>>(file_name: T) -> ServiceExuctionResult<Vec<String>> {\n     let binary = read_file_content(file_name)?;\n"
                },
                {
                    "date": 1642527248763,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -144,10 +144,11 @@\n     } else {\n         return None;\n     };\n \n-    match  from_binary(binary){\n-        \n+    match  from_binary::<T>(binary){\n+        Ok(_) => todo!(),\n+        Err(_) => todo!(),\n     }\n }\n \n pub fn parse_file<T: AsRef<str>>(file_name: T) -> ServiceExuctionResult<Vec<String>> {\n"
                },
                {
                    "date": 1642527276616,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -145,10 +145,10 @@\n         return None;\n     };\n \n     match  from_binary::<T>(binary){\n-        Ok(_) => todo!(),\n-        Err(_) => todo!(),\n+        Ok(t) => Some(t),\n+        Err(_) => None(),\n     }\n }\n \n pub fn parse_file<T: AsRef<str>>(file_name: T) -> ServiceExuctionResult<Vec<String>> {\n"
                }
            ],
            "date": 1641794179690,
            "name": "Commit-0",
            "content": "use std::fs;\nuse std::fs::File;\nuse std::io::{BufReader, BufWriter, Read};\nuse std::path::Path;\n\nuse log::{error, info};\nuse serde::{de::DeserializeOwned, Serialize};\n\nuse crate::MAX_32_MB;\nuse crate::utils::trim_tabs;\n\nconst SPLITTERS: [&str; 8] = [\",\", \";\", \":\", \"?\", \"!\", \"/\", \"\\\\\", \".\"];\nconst FILES_NOT_FOUND: &str = \"files.not.found\";\n\npub fn find_file<T: AsRef<str>>(dir: T, search_pattern: T) -> Vec<String> {\n    let output = std::process::Command::new(\"find\")\n        .arg(dir.as_ref())\n        .arg(\"-type\")\n        .arg(\"file\")\n        .arg(\"-name\")\n        .arg(search_pattern.as_ref())\n        .output()\n        .expect(FILES_NOT_FOUND);\n        let response = String::from_utf8_lossy(&output.stdout);\n        let lines = response.lines();\n        let mut names = vec![];\n        for l in lines.into_iter() {\n            names.push(l.to_lowercase());\n        }\n        names\n}\n\npub fn file_name<T: AsRef<str>>(folder: T, name: T, ext: &str) -> String {\n    let mut file_name = String::from(folder.as_ref());\n    if !file_name.ends_with(\"/\") {\n        file_name.push_str(\"/\")\n    }\n    file_name.push_str(name.as_ref());\n    if !file_name.ends_with(ext) {\n        file_name.push_str(ext);\n    }\n    file_name\n}\n\npub fn list_all_file_names<T: AsRef<str>>(dir_name: T) -> Result<Vec<String>, DictionaryError> {\n    if !{\n        let ref this = Path::new(dir_name.as_ref());\n        fs::metadata(this).is_ok()\n    } {\n        return Err(DictionaryError::throw(\"dir.not.found\", DictionaryErrorKind::NotFound));\n    }\n\n    let paths = fs::read_dir(dir_name.as_ref()).unwrap();\n    let mut files = Vec::new();\n\n    for entry in paths {\n        let dir_entry = entry?;\n        let path = dir_entry.path();\n        if !path.is_dir() {\n            let file_name = if path.file_name().is_some() {\n                path.file_name().unwrap().to_str().unwrap()\n            } else {\n                return Err(DictionaryError::throw(\"invalid.file\", DictionaryErrorKind::NotFound));\n            };\n            files.push(String::from(file_name));\n        }\n    }\n\n    Ok(files)\n}\n\npub fn list_all_files<T: AsRef<str>>(source: T) -> Result<Vec<String>, DictionaryError> {\n    let dir_name =source.as_ref();\n    if !Path::new(dir_name).exists() {\n        return Err(DictionaryError::throw(\"dir.not.found\", DictionaryErrorKind::NotFound));\n    }\n\n    let paths = fs::read_dir(dir_name).unwrap();\n    let mut files = Vec::new();\n\n    for entry in paths {\n        let dir_entry = entry?;\n        let path = dir_entry.path();\n        if !path.is_dir() {\n            let file_name = if path.file_name().is_some() {\n                path.file_name().unwrap().to_str().unwrap()\n            } else {\n                return Err(DictionaryError::throw(\"invalid.file\", DictionaryErrorKind::NotFound));\n            };\n            let mut full_file_name = String::from(dir_name);\n            if!dir_name.ends_with(\"/\") {\n                full_file_name.push_str(\"/\");\n            }\n            full_file_name.push_str(file_name);\n            files.push(String::from(full_file_name));\n        }\n    }\n\n    Ok(files)\n}\n\npub fn read_file_content<T: AsRef<str>>(file_name: T) -> ServiceExuctionResult<Vec<u8>> {\n    let mut reader: Box<dyn Read> = if !file_name.as_ref().is_empty() || !Path::new(file_name.as_ref()).exists() {\n        Box::new(BufReader::new(File::open(file_name.as_ref())?))\n    } else {\n        return Err(ServiceError{\n            message: \"file.not.found\".to_string(),\n            error_type: ServiceErrorType::ResourceNotFound\n        });\n    };\n    let mut buffer = [0; MAX_32_MB];\n    let num_read = reader.read(&mut buffer)?;\n    if num_read == 0 {\n        Err(ServiceError{\n            message: \"invalid.content\".to_string(),\n            error_type: ServiceErrorType::ResourceNotFound\n        })\n    } else {\n        Ok(Vec::from(&buffer[..num_read]))\n    }\n}\n\npub fn save<T>(file_name: &str, entity: &T) -> Result<(), DictionaryError>\nwhere\n    T: ?Sized + Serialize,\n{\n    if !file_name.is_empty() {\n        let writer = Box::new(BufWriter::new(File::create(file_name)?));\n        serde_json::to_writer_pretty(writer, entity)?;\n    } else {\n        info!(\"{}\", serde_json::to_string_pretty(entity)?);\n    }\n    Ok(())\n}\n\npub fn from_file<S: AsRef<str> ,T>(file_name: S) -> Option<T>\nwhere\n    T: ?Sized + DeserializeOwned,\n{\n    let try_to_read_file = read_file_content(file_name.as_ref());\n    let binary = if try_to_read_file.is_ok() {\n        try_to_read_file.unwrap()\n    } else {\n        return None;\n    };\n\n    if binary.is_empty() {\n        error!(\"file.[{}]is.empty\", file_name.as_ref());\n        return None;\n    }\n    let string = match String::from_utf8(binary) {\n        Ok(utf8) => utf8,\n        Err(err) => {\n            error!(\"file.[{}]is.not.readable. Err: {}\", file_name.as_ref(), err);\n            return None;\n        }\n    };\n    match serde_json::from_str::<T>(&string) {\n        Ok(json) => Some(json),\n        Err(err) => {\n            error!(\"deserialization.failed.for: {}. Err: {}\", file_name.as_ref(), err);\n            None\n        }\n    }\n}\n\npub fn parse_file<T: AsRef<str>>(file_name: T) -> ServiceExuctionResult<Vec<String>> {\n    let binary = read_file_content(file_name)?;\n    let mut content = String::from_utf8(binary)?;\n    Ok(split(&mut content))\n}\n\nfn split<T: AsMut<str>>(source: &mut T) -> Vec<String> {\n    let result = source.as_mut();\n    if result.trim().is_empty() {\n        return vec![];\n    }\n    \n    let mut result = trim_tabs(result.trim());\n\n    for ch in SPLITTERS.iter() {\n        result = result\n                        .replace(ch, \"\\n\")\n                        .trim()\n                        .to_string();        \n    }\n    let lines: Vec<String> = result.lines().map(|s| String::from(s)).collect();\n    lines\n}\n\n#[cfg(test)]\npub mod file_tests {\n    use crate::files::{file_name, list_all_file_names, parse_file, read_file_content, split};\n    use std::{path::Path, vec};\n\n    use super::find_file;\n\n    #[test]\n    fn list_files_test() {\n        let result = list_all_file_names(\"not/found/\");\n        assert!(result.is_err());\n\n        let result = list_all_file_names(\"test/en-en/\");\n        assert!(result.is_ok());\n        let files = result.unwrap();\n        assert_eq!(12, files.len());\n    }\n\n    #[test]\n    fn read_file_content_test() {\n        let result = read_file_content(\"\");\n        assert!(result.is_err());\n\n        let result = read_file_content(\"test/en-en/file_does_not_exist.txt\");\n        assert!(result.is_err());\n\n        let result = read_file_content(\"test/en-en/cease.json\");\n        assert!(result.is_ok());\n\n        let binary = result.unwrap();\n        assert_eq!(1281, binary.len());\n    }\n\n    #[test]\n    fn parse_text_test() {\n        let mut  text = String::from(\"do: something, but nothing\\n lets; play, what/ ever! do it? not do it\\n dfadsfa\\n end. A.\");\n        let result = split(&mut text);\n        assert!(!result.is_empty());\n        assert_eq!(12, result.len());\n        for any in result {\n            println!(\"-> {}\", any);\n        }\n    }\n\n    #[test]\n    fn parse_file_test() {\n        let words = parse_file(\"test/download.txt\").unwrap();\n        assert!(!words.is_empty());\n        assert_eq!(12, words.len());\n    }\n\n    #[test]\n    fn is_downloaded_test() {\n        let json_file = file_name(\"test/\", \"download\", \".txt\");\n        let mp3_file = file_name(\"test/mp3\", \"cease\", \".mp3\");\n        assert!(Path::new(&json_file).exists() && Path::new(&mp3_file).exists())\n    }\n\n    #[test]\n    fn find_files_test() {\n        let found = find_file(\"test\", \"*.json\");\n        assert!(!found.is_empty());\n        assert!(found.len() >= 1);\n\n        let found = find_file(\"test\", \"*.mp3\");\n        assert!(!found.is_empty());\n        assert!(found.len() >= 1);\n    }\n\n    #[test]\n    fn files_not_found_test() {\n        let not_found = find_file(String::from(\"test\"), String::from(\"*.xyz\"));\n        let empty: Vec<String> = vec![];\n        assert_eq!(empty, not_found);\n\n        let not_found = find_file(\"xyz/ttt\", \"*.mp3\");\n        assert_eq!(empty, not_found);\n    }\n}\n"
        }
    ]
}