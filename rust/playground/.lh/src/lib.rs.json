{
    "sourceFile": "src/lib.rs",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1646901822171,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1646901822171,
            "name": "Commit-0",
            "content": "pub mod model;\r\nuse std::{\r\n    collections::HashMap,\r\n    string::FromUtf8Error,\r\n    sync::Mutex,\r\n    thread::{sleep, spawn},\r\n    time::Duration,\r\n};\r\npub const MONITORING_ARR: [u8; 3] = [0x02, b's', 0x03];\r\npub const REQUEST_ARR: [u8; 3] = [0x02, b'q', 0x03];\r\npub const RESPONSE_ARR: [u8; 3] = [0x02, b'r', 0x03];\r\n#[macro_use]\r\nextern crate lazy_static;\r\nlazy_static! {\r\n    static ref REQUEST_HEADER: Vec<u8> = REQUEST_ARR.to_vec();\r\n    static ref RESPONSE_HEADER: Vec<u8> = RESPONSE_ARR.to_vec();\r\n    static ref MONITORING_HEADER: Vec<u8> = MONITORING_ARR.to_vec();\r\n}\r\n\r\nuse log::{error, info, warn};\r\nuse log4rs::init_file;\r\nuse model::{\r\n    Command, ExecutionStatus, ProcessResult, Response, Server, ServerCommand, ServerResponse,\r\n    SystemCommand, TaskExecutionStatus,\r\n};\r\nuse serde::{de::DeserializeOwned, Serialize};\r\n\r\nuse crate::model::{\r\n    CommandHandler, MessageType, ProcessError, ProcessErrorType, Request, SystemMessage,\r\n};\r\n\r\nlazy_static! {\r\n    static ref ACTORS: Mutex<HashMap<String, CommandHandler>> = {\r\n        let m = HashMap::new();\r\n        Mutex::new(m)\r\n    };\r\n}\r\n\r\n\r\n\r\npub fn to_binary<T: Serialize>(source: T) -> ProcessResult<Vec<u8>> {\r\n    let json = serde_json::to_string(&source)?;\r\n    Ok(Vec::from(json.as_bytes()))\r\n}\r\n\r\npub fn from_binary<T>(binary: Vec<u8>) -> ProcessResult<T>\r\nwhere\r\n    T: ?Sized + DeserializeOwned,\r\n{\r\n    if binary.is_empty() {\r\n        error!(\"binary.empty\");\r\n        return Err(ProcessError {\r\n            reason: Some(\"binary.empty\".to_string()),\r\n            error_type: ProcessErrorType::Continue,\r\n        });\r\n    }\r\n\r\n    let string = match String::from_utf8(binary) {\r\n        Ok(utf8) => utf8,\r\n        Err(err) => {\r\n            error!(\"failed.parsing.binary => Err: {}\", err);\r\n            return Err(ProcessError {\r\n                reason: Some(\"utf8_error:invalid.binary\".to_string()),\r\n                error_type: ProcessErrorType::Continue,\r\n            });\r\n        }\r\n    };\r\n    Ok(serde_json::from_str::<T>(&string)?)\r\n}\r\n\r\npub fn configure_log4rs() {\r\n    init_file(\"config/logs/log4rs.yml\", Default::default()).unwrap();\r\n    // let stdout = ConsoleAppender::builder()\r\n    //     .encoder(Box::new(PatternEncoder::new(r#\"{h(==> {d} == {l} == - [ {I} {T}:{M}]:{L} - {m} {n} )}\"#)))\r\n    //     .build();\r\n    // let config = Config::builder()\r\n    //     .appender(Appender::builder().build(\"stdout\", Box::new(stdout)))\r\n    //     .build(Root::builder().appender(\"stdout\").build(LevelFilter::Trace))\r\n    //     .unwrap();\r\n    // let _handle = log4rs::init_config(config).unwrap();\r\n    warn!(r#\"SUCCESS: Loggers are configured with dir: _log/*\"#);\r\n}\r\n\r\npub fn send_client_request(from: Vec<String>, server_name: &String, message: Vec<u8>) {\r\n    info!(\"sending 1\");\r\n    let actors = ACTORS.lock().unwrap();\r\n    info!(\"sending 2\");\r\n    let destination = actors.get(server_name);\r\n    if destination.is_some() {\r\n        info!(\"sending ....\");\r\n        let correlation_id = \"123\".to_string();\r\n        let request = Request {\r\n            from,\r\n            road_map: vec![],\r\n            payload: Some(message),\r\n            correlation_id: Some(correlation_id.clone()),\r\n            internal_command: Some(ServerCommand::Ack(101)),\r\n            command: Some(Command::Execute(correlation_id)),\r\n        };\r\n        let bin_req = Vec::from(serde_json::to_string(&request).unwrap().as_bytes());\r\n        let mt = MessageType::new_request(bin_req);\r\n        let client_request = mt.to_binary();\r\n        info!(\"sending {:?} to {}\", client_request, server_name);\r\n        destination.unwrap().send(client_request);\r\n    } else {\r\n        error!(\"server {} not found\", server_name);\r\n    }\r\n}\r\n\r\npub fn start_server(server_name: String) {\r\n    let (tx, rx) = crossbeam::channel::unbounded();\r\n    let mut actors = ACTORS.lock().unwrap();\r\n    actors.insert(server_name.clone(), CommandHandler { sender: tx.clone() });\r\n    // let _t = spawn(move || server(server_name, rx, tx.clone()));\r\n    let server = Server::<Request, Response> {\r\n        handle_request: process_request,\r\n        handle_response: process_response,\r\n        handler_status: handle_srv_command,\r\n    };\r\n    let _t = spawn(move || run_server(server_name, rx, tx.clone(), server));\r\n}\r\n\r\npub fn process_request(from: &str, req: Request) {\r\n    info!(\"#1 process server request\");\r\n    spawn(move || test(Box::new(\"done\".to_string())));\r\n\r\n    let response = Response {\r\n        from: req.from,\r\n        payload: None,\r\n        correlation_id: None,\r\n        server_response: None,\r\n        status: Some(ExecutionStatus::Ok(\"done\".to_string())),\r\n    };\r\n\r\n    let actors = ACTORS.lock().unwrap();\r\n    let destination = actors.get(from);\r\n    if destination.is_some() {\r\n        let handler = destination.unwrap();\r\n        let message = MessageType::new_response(\r\n            serde_json::to_string(&response)\r\n                .unwrap()\r\n                .as_bytes()\r\n                .to_vec(),\r\n        );\r\n        handler.send(message.to_binary());\r\n    }\r\n}\r\n\r\npub fn process_response(_response: Response) {\r\n    info!(\"#2 process server response\");\r\n}\r\n\r\npub fn handle_srv_command(_cmd: ServerCommand) -> ProcessResult<ServerResponse> {\r\n    info!(\"#INFO server command\");\r\n    Ok(ServerResponse::Ok)\r\n}\r\n\r\npub fn run_server(\r\n    server_name: String,\r\n    receiver: crossbeam::channel::Receiver<Vec<u8>>,\r\n    sender: crossbeam::channel::Sender<Vec<u8>>,\r\n    server: Server<Request, Response>,\r\n) {\r\n    loop {\r\n        info!(\"looping\");\r\n        if let Ok(bin) = receiver.recv_timeout(Duration::from_secs(1)) {\r\n            let message = MessageType::parse(&bin);\r\n            info!(\"SRV[{}] => Message: {:?}\", &server_name, message);\r\n            match message {\r\n                MessageType::ClientRequest(source) => {\r\n                    let request = from_binary::<Request>(source).unwrap();\r\n                    let sc = server_name.clone();\r\n                    let lr = request.clone();\r\n\r\n                    let _ = spawn(move || (server.handle_request)(&sc.clone(), request.clone()));\r\n                    if lr.internal_command.is_some() {\r\n                        let bin_cmd = to_binary(lr.internal_command.unwrap()).unwrap();\r\n                        let mt = MessageType::new_monitoring_message(bin_cmd);\r\n                        let _ = sender.try_send(mt.to_binary());\r\n                    }\r\n                    continue;\r\n                }\r\n                MessageType::WorkerResponse(source) => {\r\n                    let mut response = from_binary::<Response>(source).unwrap();\r\n                    let v = response.from.pop();\r\n                    if v.is_some() {\r\n                        /*\r\n                            Forward the response to the next recipient.\r\n                        */\r\n                        let recipient = v.unwrap();\r\n                        info!(\"ATT! sending to {}\", recipient);\r\n                        let bin = serde_json::to_string(&response)\r\n                            .unwrap()\r\n                            .as_bytes()\r\n                            .to_vec();\r\n                        info!(\"RESPONSE: {:?}\", &response);\r\n                        let message = MessageType::new_response(bin);\r\n                        let actors = ACTORS.lock().unwrap();\r\n                        let handler = actors.get(&recipient);\r\n                        if handler.is_some() {\r\n                            let _ = handler.unwrap().send(message.to_binary());\r\n                        }\r\n                    } else {\r\n                        (server.handle_response)(response);\r\n                        continue;\r\n                    };\r\n                }\r\n                MessageType::Monitoring(binary) => {\r\n                    let cmd = from_binary::<ServerCommand>(binary);\r\n                    let _status = match cmd {\r\n                        Ok(command) => (server.handler_status)(command),\r\n                        Err(_err) => continue,\r\n                    };\r\n\r\n                    continue;\r\n                }\r\n                _ => {\r\n                    error!(\r\n                        \"{} -> Client request must be provided {:?}\",\r\n                        &server_name, bin\r\n                    );\r\n                    continue;\r\n                }\r\n            };\r\n        } else {\r\n            info!(\"server [{}] is awaiting for something\", &server_name);\r\n            continue;\r\n        }\r\n    }\r\n}\r\n\r\npub fn exchange_command(from: String, to: String, command: SystemCommand) {\r\n    let actors = ACTORS.lock().unwrap();\r\n    let destination = actors.get(&to);\r\n    if destination.is_some() {\r\n        let handler = destination.unwrap();\r\n        let system_message = SystemMessage {\r\n            from: from.clone(),\r\n            payload: None,\r\n            correlation_id: None,\r\n            command: Some(command.clone()),\r\n        };\r\n\r\n        let result = serde_json::to_string(&system_message);\r\n        let binary = Vec::from(result.unwrap().as_bytes());\r\n        let _ = handler.send(binary);\r\n    }\r\n}\r\n\r\npub fn exchange_message(from: String, to: String, message: String, correlation_id: Option<String>) {\r\n    let actors = ACTORS.lock().unwrap();\r\n    let destination = actors.get(&to);\r\n    if destination.is_some() {\r\n        let handler = destination.unwrap();\r\n        let system_message = SystemMessage {\r\n            from: from.clone(),\r\n            payload: Some(Vec::from(message.as_bytes())),\r\n            correlation_id,\r\n            command: None,\r\n        };\r\n\r\n        let result = serde_json::to_string(&system_message);\r\n        let binary = Vec::from(result.unwrap().as_bytes());\r\n        info!(\"sending message: {:?}\", system_message);\r\n        let _ = handler.send(binary);\r\n    }\r\n}\r\n\r\nfn execute<T: Sized>(\r\n    f: &dyn Fn(Box<T>) -> ProcessResult<()>,\r\n    param: Box<T>,\r\n    sender: crossbeam::channel::Sender<Vec<u8>>,\r\n) {\r\n    let c_id = \"123\".to_string();\r\n    send_message(&TaskExecutionStatus::InProgress(c_id.clone()), &sender);\r\n    match f(param) {\r\n        Ok(_) => send_message(&TaskExecutionStatus::Ok(c_id.clone()), &sender),\r\n        Err(_) => send_message(&TaskExecutionStatus::Error(c_id), &sender),\r\n    };\r\n}\r\n\r\nfn send_message(status: &TaskExecutionStatus, sender: &crossbeam::channel::Sender<Vec<u8>>) {\r\n    let in_progress = serde_json::to_string(status);\r\n    let msg = Vec::from(in_progress.unwrap().as_bytes());\r\n    let _ = sender.try_send(msg);\r\n}\r\n\r\nfn test(_source: Box<String>) -> ProcessResult<()> {\r\n    info!(\"let sleep for 5 sec\");\r\n    sleep(Duration::from_secs(5));\r\n    info!(\"DONE. Lets finish....\");\r\n    Ok(())\r\n}\r\n\r\nimpl From<FromUtf8Error> for ProcessError {\r\n    fn from(_err: FromUtf8Error) -> Self {\r\n        ProcessError {\r\n            reason: Some(\"utf8_error\".to_string()),\r\n            error_type: ProcessErrorType::Continue,\r\n        }\r\n    }\r\n}\r\n\r\nimpl From<serde_json::Error> for ProcessError {\r\n    fn from(_err: serde_json::Error) -> Self {\r\n        ProcessError {\r\n            reason: Some(\"parsing.error\".to_string()),\r\n            error_type: ProcessErrorType::Continue,\r\n        }\r\n    }\r\n}\r\n\r\n#[cfg(test)]\r\nmod unit_tests {\r\n    use crate::MessageType;\r\n\r\n    fn process_binary(binary: &Vec<u8>) -> MessageType {\r\n        if binary.len() < 3 {\r\n            return MessageType::Error;\r\n        }\r\n\r\n        let prefix = &binary[0..3];\r\n        match prefix {\r\n            [2, 119, 3] => MessageType::WorkerResponse(Vec::from(&binary[3..])),\r\n            [2, 99, 3] => MessageType::ClientRequest(Vec::from(&binary[3..])),\r\n            _ => MessageType::Error,\r\n        }\r\n    }\r\n\r\n    #[test]\r\n    fn match_binaries_test() {\r\n        let worker = [0x02, b'w', 0x03, b'a', b'l', b'e', b'x'];\r\n        let client = [0x02, b'c', 0x03, b'a', b'l', b'e', b'x'];\r\n        let empty = [];\r\n        let any = [99, 100, 101, 102];\r\n        let w = process_binary(&Vec::from(worker));\r\n        let c = process_binary(&Vec::from(client));\r\n        let e = process_binary(&Vec::from(empty));\r\n        let a = process_binary(&Vec::from(any));\r\n\r\n        assert_eq!(MessageType::WorkerResponse(Vec::from(\"alex\".as_bytes())), w);\r\n        assert_eq!(MessageType::ClientRequest(Vec::from(\"alex\".as_bytes())), c);\r\n        assert_eq!(MessageType::Error, e);\r\n        assert_eq!(MessageType::Error, a);\r\n\r\n        let v = vec![\r\n            2, 99, 3, 123, 34, 102, 114, 111, 109, 34, 58, 34, 99, 108, 105, 101, 110, 116, 49, 34,\r\n            44, 34, 112, 97, 121, 108, 111, 97, 100, 34, 58, 91, 49, 49, 53, 44, 49, 49, 49, 44,\r\n            49, 48, 57, 44, 49, 48, 49, 44, 51, 50, 44, 49, 49, 53, 44, 49, 49, 54, 44, 49, 49, 52,\r\n            44, 49, 48, 53, 44, 49, 49, 48, 44, 49, 48, 51, 93, 44, 34, 99, 111, 114, 114, 101,\r\n            108, 97, 116, 105, 111, 110, 95, 105, 100, 34, 58, 34, 49, 50, 51, 34, 44, 34, 105,\r\n            110, 116, 101, 114, 110, 97, 108, 95, 99, 111, 109, 109, 97, 110, 100, 34, 58, 123, 34,\r\n            65, 99, 107, 34, 58, 49, 48, 49, 125, 44, 34, 99, 111, 109, 109, 97, 110, 100, 34, 58,\r\n            123, 34, 69, 120, 101, 99, 117, 116, 101, 34, 58, 34, 49, 50, 51, 34, 125, 125,\r\n        ];\r\n        let r = process_binary(&v);\r\n        assert_eq!(\r\n            MessageType::ClientRequest(vec![\r\n                123, 34, 102, 114, 111, 109, 34, 58, 34, 99, 108, 105, 101, 110, 116, 49, 34, 44,\r\n                34, 112, 97, 121, 108, 111, 97, 100, 34, 58, 91, 49, 49, 53, 44, 49, 49, 49, 44,\r\n                49, 48, 57, 44, 49, 48, 49, 44, 51, 50, 44, 49, 49, 53, 44, 49, 49, 54, 44, 49, 49,\r\n                52, 44, 49, 48, 53, 44, 49, 49, 48, 44, 49, 48, 51, 93, 44, 34, 99, 111, 114, 114,\r\n                101, 108, 97, 116, 105, 111, 110, 95, 105, 100, 34, 58, 34, 49, 50, 51, 34, 44, 34,\r\n                105, 110, 116, 101, 114, 110, 97, 108, 95, 99, 111, 109, 109, 97, 110, 100, 34, 58,\r\n                123, 34, 65, 99, 107, 34, 58, 49, 48, 49, 125, 44, 34, 99, 111, 109, 109, 97, 110,\r\n                100, 34, 58, 123, 34, 69, 120, 101, 99, 117, 116, 101, 34, 58, 34, 49, 50, 51, 34,\r\n                125, 125,\r\n            ]),\r\n            r\r\n        );\r\n    }\r\n}\r\n"
        }
    ]
}